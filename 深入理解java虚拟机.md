##深入理解java虚拟机##
### java内存区域和内存溢出异常 ###
1、java运行时数据区域包括：

- **程序计数器**
当前线程所执行字节码的行号指示器，通过改变这个计数器的值来选取下一条需要执行的字节码指令。每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，这类内存区域为线程私有的内存，此区域是在java虚拟机中唯一一个没有规定任何OutOfMemoryError情况的区域。  
	
- **java虚拟机栈**
它也是线程私有的，其生命周期和线程相同，以前经常提的栈就是指java虚拟机栈中的局部变量表部分。局部变量表所需的内存分配在编译期间完成分配。  

在java虚拟机规范中，对这个区域规定了两种方式的异常：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到内存，将抛出OutOfMemory异常。
	
- **本地方法栈**
本地方法栈为虚拟机使用到的native方法服务，他也会抛出StackOverflowError和OutOfMemory异常  
	
- **java堆**
java堆是java虚拟机所管理的内存中最大的一块，java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，几乎所有的对象实例都在此区域分配内存。java虚拟机规范的描述时：所有的对象实例以及数组都在堆上分配内存。  

该区域也是垃圾收集器管理的主要区域，也称为GC堆。在java堆中还可以分为新生代和老年代。虚拟机的扩展通过-Xmx 和-Xms来配置。物理上可以不连续，但是逻辑上要求是连续的。  
	
- **方法区**
该方法区用于存储已被虚拟机加载的类信息、常量、静态变量等数据。  
	
- **运行时常量池**
它是方法区的一部分，用于存放编译期生成的字面量和符号引用。  
	
- **直接内存**
直接内存的分配不会受到java堆大小的限制，但是会受本机物理内存的限制。

###HotSpot虚拟机对象探秘###

- **对象的创建**
对象所需内存的大小在类加载完成后便可确定下来，为对象分配内存的任务等同于把一块确定大小的内存从java堆中划分出来。分配方式有：指针碰撞和空闲列表。为了内存分配的线程安全，有了TLAB，即本次线程分配缓冲的概念，每个线程都在自己的区域分配内存，只有在TLAB用完并且重新分配TLAB时，才需要同步锁定。  

- **对象的内存布局**
对象在内存中存储的布局可以分为三个部分：对象头，实例数据和对齐填充。  
实例数据部分相同宽度的字段总是被分配在一起。

- **对象的访问定位**
java程序需要从栈上的reference数据去访问堆上的对象实例，主流的对象访问方式有句柄和直接指针方式

### 垃圾收集器与内存分配策略
回答三个问题：
- 哪些内存需要回收
- 什么时候回收
- 如何回收

程序计数器、虚拟机栈、本地方法栈随线程而生、随线程而灭；栈帧中分多少内存基本是在类结构确定下来时就已经告知的，即编译期可知。但是java堆和方法区则不一样，我们在程序运行期间才会知道会创建多少对象，这部分内存的分配和回收都是动态的。

- **判断对象是否存在**
在堆里面存放着java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事是确定这些对象之中，哪些还存活着，哪些已经死去.
简单的判断对象是否存活的办法是引用计数法，每当有一个地方引用对象时，该对象的引用计数器就加1，引用失效就减1，这样任何计数器为0 的对象就是不可能再被使用的。还有一种在主流商用编程语言中使用的算法叫可达性分析算法，当一个对象到GC Roots没有任何引用链相连时，则证明对象时不可用的。

- **再谈引用**
我们希望描述这样的对象：当内存空间还足够时，则能保留在内存中，如果内存空间在进行垃圾回收后还是很紧张，则可以抛弃这些对象。
分为四种引用：强引用，软引用、弱引用、虚引用

- **怎么判定一个无用的类**
在新生代中，常规应用进行一次垃圾回收一般可以回收70%~95%的空间
判断无用的类：
1、该类的所有实例都已经被回收，java堆中不存在该类的任何实例；
2、加载该类的ClassLoader已经被回收；
3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 垃圾收集算法
- **标记清除算法**
首先标记出需要回收的对象，在标记完成后统一回收所有被标记的对象。
它的不足：一是效率问题，标记和清除的效率都不高；二是空间问题，清除以后会产生大量不连续的内存片段，空间碎片太多可能导致在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收。
- **复制算法**
这种算法是将内存划分为两个相等大小的区域，如果一个半区用完，就将该半区存活的对象复制到另一个半区。这样是每次都对整个半区进行回收，不用考虑内存碎片的问题。但这样的缺点是内容利用率太低，只有一半。
Eden区和Survivor区的大小比例是8:1，内存新生代分为一个Eden区和两个Survivor区，这样会牺牲10%的内存空间。当Survivor内存区域大小不够时，需要老年代进行分配担保。
- **标记整理算法**
标记整理跟标记清除算法原理差不多，只是在后续过程中不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界意外的内存。
- **分代收集算法**
新生代在回收时如果发现有大批对象死去，就采用复制算法；在老年代，需要采用`标记整理`或者`标记清除算法`。

### 内存分配与回收策略
- **对象优先在Eden区分配**
大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间进行内存分配时，虚拟机将发起一次Minor GC（新生代GC）
- **大对象直接分配在老年代**
所谓的大对象，是指需要大量连续空间的java对象，最典型的大对象就是那些很长的字符串和数组。  
虚拟机提供了一个参数：-XX:PretenureSizeThreshold参数，令大于这个值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。
- **长期存活的对象将进入老年代**
每个对象都有一个对象年龄计数器，对象在Survivor区中每“熬过”一次MinorGC，年龄就增加1岁，当他的年龄增加到一定程度（默认15岁），就会被晋升到老年代中。年龄阈值设置参数 -XX:MaxTenuringThreshold。
- **动态对象年龄判定**
虚拟机并不是永远的要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
- **空间分配担保**
新生代使用复制收集算法，但为了内存使用率，只使用其中一个Survivor空间作为轮换备份，因此当出现了大量对象在Minor GC后仍然存活的情况，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。


### 虚拟机性能监控与故障处理工具
- **jps**
用于列出正在运行的虚拟机进程、并显示虚拟机执行主类名称和这些进程的本次虚拟机唯一ID（LVMID），下图是jps的主要参数：
![Alt text](./1480553956203.png)
- **jstat**:虚拟机统计信息监视工具
用于监视虚拟机各种运行状态信息的命令行工具，它可以显示本地或者远程虚拟机进程中的类装载、内存
垃圾收集、JIT编译等运行数据。
jstat命令格式：
jstat [option vmid [internal[s|ms] [count] ]  ]
option代表着用户希望查询的虚拟机信息，主要分为三类：类装载、垃圾回收、运行期编译状况。
![Alt text](./1480554416605.png)
- **jinfo**:Java配置信息工具
jinfo的作用是实时的查看和调整虚拟机各项参数。
jinfo -flag **参数能查询未被显式指定的参数的系统默认值。
- **jstack**: Java堆栈跟踪工具
- jstack命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条县城正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等就是导致线程长时间停顿的常见原因。
- ![Alt text](./1480640248009.png)

### 调优案例分析与实战
- 控制Full GC频率的关键是看应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。
- 在高性能硬件上部署程序，目前主要有两种方式：
	- 通过64位JDK使用大内存
	- 使用若干个32位虚拟机建立逻辑集群来利用硬件资源

